import { ClientFactory } from './client';
import { Command, flags } from '@oclif/command'
import { google, calendar_v3 } from 'googleapis';
import { MY_CLIENT_ID, MY_CLIENT_SECRET } from './secrets'
import fs = require("fs");
import path = require("path");
import { addDays, format } from 'date-fns'

class GoogleCalendarToOrgMode extends Command {
  static description = `
  Outputs your main Google Calendar in Org mode format
  `
  static flags = {
    // add --version flag to show CLI version
    version: flags.version({ char: 'v' }),
    help: flags.help({ char: 'h' }),
    port: flags.integer({ default: 3000, description: 'The port to run the callback server on localhost.' }),
    backDays: flags.integer({ default: 720, description: "How many days back to process events." }),
    forwardDays: flags.integer({ default: 365, description: "How many days forward to process events." })
  }

  static args = [
    {
      name: 'file',
      required: true,
      description: 'Path to output the Org file (will be overwritten)'
    }]

  async run() {
    // parse arguments and create a client
    const { args, flags } = this.parse(GoogleCalendarToOrgMode)
    const factory = new ClientFactory({
      clientId: MY_CLIENT_ID,
      clientSecret: MY_CLIENT_SECRET,
      port: flags.port,
      tokenFileName: path.join(this.config.dataDir, `token.json`),
      scopes: ['https://www.googleapis.com/auth/calendar.events.owned.readonly']
    });
    const client = await factory.createClient()

    // create the request for the calendar entries
    const calendar = google.calendar({ version: 'v3', auth: client })
    const timeMin = addDays(new Date(), -flags.backDays).toISOString()
    const timeMax = addDays(new Date(), flags.forwardDays).toISOString()
    this.log(`Processing events in the range ${timeMin} to ${timeMax}`)
    const listParams: calendar_v3.Params$Resource$Events$List = {
      calendarId: "primary",
      singleEvents: true,
      timeMin: timeMin,
      timeMax: timeMax,
    }

    // process the entries
    const orglines = new Set<string>()

    while (true) {
      const eventsResp = await calendar.events.list(listParams)
      eventsResp.data.items?.
        filter(e => e.status != "cancelled").
        filter(e => e.summary != null).
        filter(e => e.start?.dateTime != null).
        filter(acceptedOrCreated).
        map(formatEntry).
        forEach(e => orglines.add(e))

      if (eventsResp.data.nextPageToken == null) {
        break
      }
      listParams.pageToken = eventsResp.data.nextPageToken
    }

    // Generate the Org file
    const outStream = fs.createWriteStream(args.file)
    outStream.write(`
* Google Calendar: primary
These entries have been automatically generated, do not edit this file!
`)
    orglines.forEach(line => outStream.write(`${line}\n\n`))
    outStream.close()
  }
}

function formatEntry(e: calendar_v3.Schema$Event): string {
  const start = new Date(e.start!.dateTime!.valueOf())
  const strStartDate = format(start, 'yyyy-LL-dd EEE')
  const strStartTime = format(start, 'HH:mm')
  let strEndTime = ""
  if (!e.endTimeUnspecified) {
    strEndTime = "-" + format(new Date(e.end!.dateTime!.valueOf()), 'HH:mm')
  }
  let result = `** ${e.summary} ${strStartTime}${strEndTime} <${strStartDate}>`
  return result
}

function acceptedOrCreated(e: calendar_v3.Schema$Event): boolean {
  // console.log(`==> considering ${e.summary}`)
  if (e.attendees == null) {
    return true
  }

  const myself = e.attendees.find(e => e?.self == true)
  // console.log(`I found myself = ${myself}`)
  if (myself && myself.responseStatus == "accepted") {
    return true
  }

  // console.log(`xxx DENIED`)
  return false
}

export = GoogleCalendarToOrgMode
